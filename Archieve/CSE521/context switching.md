---
title: context switching
toc: true
date: 2017-07-30
tags: [OS]
top: 8
---


# Context Switching
## Now: Why Are We Doing All This Stuff?

* CPU multiplexing: a historical perspective.
* Preemption and context switching.

## CPU Limitations: Number
(Historically) There is only one! Why?
* Potentially the most **expensive** and **complex** component of the system!

(Recently) You may have many. Why?
* Multiple cores have emerged as a solution to **thermal- and energy-management** issues caused by transistor density.
* But generally, even if you have more than one, there are **fewer** cores than tasks to be run.

![multicore](http://or9a8nskt.bkt.clouddn.com/multicore.png)

##CPU Limitations
How does the CPU compare to other parts of the system—memory, disks, etc.?

* It is **way faster**!
* **Faster** than **memory**—usually addressed on the processor through out-of-order execution.
* **Way faster** than **disk**—addressed by the operating system.
* **Way faster** than **you**!—partially addressed by the operating system. (Nothing the operating system can really do about your limitations.)

## Human Perceptual Limitations
Can you express these delays to a 1 GHz processor?

* 15 ms "rule of thumb": 15,000,000 clock cycles!
* 40 ms based on 25 frames-per-second for "smooth" video: 40,000,000 clock cycles!
* 100 ms was the rule for old telephone systems, the delay point after which human conversation patterns start to break down: 100,000,000 clock cycles!

## Ancient History

![TheHarvardMarkIcomputer](http://or9a8nskt.bkt.clouddn.com/TheHarvardMarkIcomputer.png)

## The Garden

* Long long ago, in a land before time, computers did not multitask. **They did one thing at a time**.
* That one thing had complete access to the machine in was running on.
* The operating system—​if there was one—​was really just a library of routines to make programming easier. All abstractions, no multiplexing.

## The Fall of Computing

* At some point **more people** wanted to use the computer. That was annoying, because the geeks didn’t have it all to themselves anymore, but they just told people to form a line.

![People in line](http://or9a8nskt.bkt.clouddn.com/PEOPLEINLINE.png)


## The Further Fall of Computing

* At some point people wanted to **interact** with the computer, even multiple people interacting with the computer **at the same time**! Now what were the geeks to do?

## Give the Geeks Some Credit

* They solved these problems by building **operating systems**. Scheduling evolved to meet the needs of computer users.

## The Rise of Multiprocessing

![Schedule the humans](http://or9a8nskt.bkt.clouddn.com/schedulethehumans.png)

![Batch scheduling](http://or9a8nskt.bkt.clouddn.com/batchscheduling.png)

* **Batch systems** processed jobs in bulk, with predetermined input from files or other data sources. 
* **Interactive systems** waited for input from users.

## Problems with Batch Scheduling
Recall one of the "problems" with the CPU
* It is **faster** than other system components!

What problem does this create for simple batch scheduling?
* **Inefficiency**! Usage of slower parts of the system will cause the CPU to stall waiting for them to finish.

## Solution: Context Switching
![Contextsswitching](http://or9a8nskt.bkt.clouddn.com/contextswitching.png)
## Birth of the Operating System

* Operating systems emerged partly to **hide delays** caused by slow devices to **keep the processor active**.
* Hiding processor delays requires only **cooperative scheduling**: threads only stop running when they require a long-latency operation.

## Supporting Multiple Interactive Users

Supporting multiple users requires the notion that multiple tasks are running **simultaneously** or **concurrently**, either:

* One task per user for multiple users, or
* multiple tasks for a single user, or
* multiple tasks for multiple users.

![Multiple jobs](http://or9a8nskt.bkt.clouddn.com/multiplejobs.png)

## The Illusion of Concurrency
How is this accomplished?
* Remember human perceptual limits?
* The processors **rapidly** switches between tasks creating the notion of concurrency!
* We refer to these transitions as **context switches**.

![Concurrency](http://or9a8nskt.bkt.clouddn.com/concurrencyfigure.png)


## Implementing Context Switching
First problem: **how does the operating system get control**?

* Hardware interrupts.
* Software interrupts.
* Software exceptions.

**But what if these things don’t happen?**

## Timer Interrupts

* **Timer interrupts** generated by a timer device ensure that the operating system regains control of the system at regular intervals.
* Timer interrupts are the basis of **preemptive scheduling**: the operating system doesn’t wait for the thread to stop running, instead it preempts it.
* Rest of interrupt handling is unchanged.

## The Illusion of Concurrency
* Timer interrupts mean that a running thread may be stopped **at any time**.
* When the thread restarts we want it to appear that nothing has happened, that execution was not interrupted.
    * Of course other parts of the system might have changed, but the CPU state should be **identical**.
* How do we do this?

## Saving Thread State
What does thread state consist of?

* Registers
* Stack

We rely on memory protection to keep the stack unchanged until we restart the thread.

## OS/161 Example

* Saving thread state is the **first thing** that happens when the interrupt service routine is triggered. (Why?)
* Saved state is sometimes known as a **trap frame**.


## Context Switching
* Threads switch to a separate kernel stack when executing in the kernel. Why?
    * The kernel doesn’t trust (or want to pollute) the user thread’s stack.